#-*-coding:utf-8*-
#!/usr/bin/env python
''''''
'''
Мой коммент: аналог static-переменных и методов в Java 
Переменные класса РАЗДЕЛЯЕМЫ – ДОСТУП к ним могут ПОЛУЧАТЬ все ЭКЗЕМПЛЯРЫ этого класса.
Переменная класса существует только одна, поэтому когда любой из объектов изменяет переменную класса
это изменение отразится и ВО ВСЕХ ОСТАЛЬНЫХ ЭКЗЕМПЛЯРАХ того же КЛАССА
'''
class Robot:
    '''Представляет робота с именем.'''
    # Выше применение строк документации для классов
    # Переменная КЛАССА, содержащая количество роботов
    population = 0
    # Конструктор класса
    def __init__(self, name):
        '''Инициализация данных'''
        # Выше применение строк документации для методов
        self.name = name
        print('(Инициализация {0})'.format(self.name))
        #При создании этой личности, робот добавляется к переменной population
        Robot.population += 1

    # Деструктор класса
    def __del__(self):
        ''' Я умираю '''
        print('Я умираю')
        print('{0} уничтожается!'.format(self.name))
        Robot.population -= 1
        if Robot.population == 0:
            print('{0} , был последним'.format(self.name))
        else:
            print('Осталось {0:d} работающих роботов.'.format(Robot.population))

    def sayHi(self):
        ''' Приветствие робота'''
        print('Приветствую! Мои хозяева называют меня {0}.'.format(self.name))

    '''
    Внутри класса можно создать метод, который будет доступен бЕЗ СОЗДАНИЯ ЭКЗЕМПЛЯРА класса( статический метод). 
    Для этого перед определением метода внутри класса следует указать ДЕКОРАТОР @staticmethod.
    Обратите внимание на то, что в определении статического метода НЕТ ПАРАМЕТРА self. 
    Это означает, что внутри статического метода НЕТ ДОСТУПА к АТРИБУТАМ и МЕТОДАМ ЭКЗЕМПЛЯРА класса
    '''
    # @staticmethod
    # def howMany():
    #     ''' Выводит численность роботов'''
    #     print('У нас {0:d} роботов'.format(Robot.population))

    ''' 
    Метод howMany принадлежит классу, а не объекту. Это означает, что мы можем определить его как classmethod или staticmethod, 
    В ЗАВИСИМОСТИ ОТ ТОГО, НУЖНО ЛИ НАМ ЗНАТЬ, В КАКОМ КЛАССЕ МЫ НАХОДИМСЯ. Поскольку нам не нужна такая информация, мы воспользуемся staticmethod
    В качестве первого параметра в метод класса передается ССЫЛКА НА КЛАСС cls, а НЕ НА ЭКЗЕМПЛЯР КЛАССА.
    '''
    @classmethod
    def howMany(cls):
        ''' Выводит численность роботов'''
        print('У нас {0:d} роботов'.format(Robot.population))
        print('Мы находимся в классе ', cls)

if __name__ == '__main__':

    droid1 = Robot('R2-D2')
    droid1.sayHi()
    Robot.howMany()

    droid2 = Robot('C2-D3')
    droid2.sayHi()
    Robot.howMany()

    print("Здесь роботы могут проделать какую-то работу.")
    print("Роботы закончили свою работу. Давайте уничтожим их.")

    del droid1, droid2
    #del droid2
    '''
    В Python все члены класса (включая данные) являются ПУБЛИЧНЫМИ (public), а все методы – ВИРТУАЛЬНЫМИ (virtual). 
    ИСКЛЮЧЕНИЕ: ЕСЛИ ИМЯ ПЕРЕМЕННОЙ НАЧИНАЕТСЯ С ДВОЙНОГО ПОДЧЁРКИВАНИЯ, как, например, __privatevar, 
    Python делает эту переменную ПРИВАТНОЙ (private). Поэтому принято имя любой переменной, которая должна использоваться только внутри класса или объекта, 
    начинать с подчёркивания; все же остальные имена являются публичными, и могут использоваться в других классах/объектах.
    '''

    '''
    В этом примере мы также наблюдали применение строк документации для классов, равно как и для методов. 
    Во время выполнения мы можем обращаться к строке документации класса при помощи “Robot.__doc__”, а к строке документации метода – при помощи
    “Robot.sayHi.__doc__”.
    '''

    '''
    Метод __del__ запускается лишь тогда, когда объект перестаёт использоваться, а поэтому заранее неизвестно, когда именно этот момент наступит.
    Чтобы увидеть его в действии явно, придётся воспользоваться оператором del, что мы и сделали выше.
    '''