''''''
'''
Представим, что нам нужно написать программу, которая отслеживает информацию о преподавателях и студентах в колледже.
У них есть некоторые ОБЩИЕ ХАРАКТЕРИСТИКИ: имя, возраст и адрес. Есть также и СПЕЦИФИЧЕСКИЕ ХАРАКТЕРИСТИКИ, такие как
зарплата, курсы и отпуск для преподавателей, а также оценки и оплата за обучение для студентов.
Можно создать для них независимые классы и работать с ними, но тогда ДОБАВЛЕНИЕ КАКОЙ-ЛИБО НОВОЙ ОБЩЕЙ ХАРАКТЕРИСТИКИ
потребует добавления её к КАЖДОМУ из этих независимых классов В ОТДЕЛЬНОСТИ, что делает программу НЕПОВОРОТЛИВОЙ.
Лучше создать ОБЩИЙ КЛАСС с именем SchoolMember,
а затем сделать так, чтобы классы преподавателя и студента НАСЛЕДОВАЛИ этот класс,
т.е. чтобы они стали ПОДТИПАМИ этого типа (класса), после чего добавить любые СПЕЦИФИЧЕСКИЕ характеристики к этим подтипам.
У такого подхода есть множество достоинств. Если мы добавим/изменим какую-либо функциональность в SchoolMember,
это АВТОМАТИЧЕСКИ ОТОБРАЗИТСЯ и ВО ВСЕХ ПОДТИПАХ. Например, мы можем добавить новое поле удостоверения для преподавателей
и студентов, ПРОСТО ДОБАВИВ ЕГО К КЛАССУ SCHOOLMEMBER.
С другой стороны, ИЗМЕНЕНИЯ В ПОДТИПАХ НИКАК НЕ ВЛИЯЮТ НА ДРУГИЕ ПОДТИПЫ.
Ещё одно достоинство состоит в том, что ОБРАЩАТЬСЯ К ОБЪЕКТУПОДТИПА преподавателя или студента МОЖНО КАК К ОБЪЕКТУ SchoolMember,
что может быть ПОЛЕЗНО в ряде случаев, например, для подсчёта количества человек в школе.
Когда ПОДТИП МОЖЕТ БЫТЬ ПОДСТАВЛЕН В ЛЮБОМ МЕСТЕ, где ОЖИДАЕТСЯ РОДИТЕЛЬСКИЙ ТИП,
т.е. ОБЪЕКТ СЧИТАЕТСЯ ЭКЗЕМПЛЯРОМ РОДИТЕЛЬСКОГО КЛАССА, это называется ПОЛИМОРФИЗМОМ
'''

class SchoolMember():
    '''Базовый(суперкласс для классов Student и Teacher. Представляет любого человека в школе.'''
    '''    
    Можно создать для них независимые классы и работать с ними, но тогда добавление какой-либо н
    студента наследовали этот класс, т.е. чтобы они стали подтипами этого типа (класса), после чего добавить любые
    специфические характеристики к этим подтипам.
    Заметьте также, что код родительского класса используется МНОГОКРАТНО,
    и НЕТ НЕОБХОДИМОСТИ КОПИРОВАТЬ ЕГО ВО ВСЕ КЛАССЫ, как пришлось бы в случае использования независимых классов.
    '''

    def __init__(self, name, age):
        self.name = name
        self.age = age
        print('(Создан SchoolMember: {0})'.format(self.name))

    def tell(self):
        '''Вывести информацию.'''
        print('Имя:"{0}" Возраст:"{1}"'.format(self.name, self.age), end=" ")


"""
Чтобы воспользоваться наследованием, при определении класса мы указываем имена его базовых классов в виде кортежа, 
следующего за сразу за его именем.

"""

class Teacher(SchoolMember):
    '''Представляет подкласс преподователя'''

    '''
    Метод __init__ базового класса вызывается явно при помощи переменной self, 
    чтобы инициализировать ЧАСТЬ ОБЪЕКТА, относящуюся к базовому классу
    Это очень важно запомнить: Python НЕ ВЫЗЫВАЕТ конструктор базового класса АВТОМАТИЧЕСКИ 
    – его необходимо вызывать самостоятельно в явном виде.
    '''
    def __init__(self, name, age, salary):
        SchoolMember.__init__(self, name, age)
        self.salary = salary
        print('Создан Teacher: {0}'.format(self.name))

    def tell(self):
        '''
        Здесь же мы видим, как можно вызывать методы базового класса, предваряя запись имени метода именем класса,
        а затем передавая переменную self вместе с другими аргументами.
        '''
        SchoolMember.tell(self)
        print('Зарплата {0:d}'.format(self.salary))


class Student(SchoolMember):
    ''' Представляет студента '''

    def __init__(self, name, age, marks):
        SchoolMember.__init__(self, name, age)
        self.marks = marks
        print('Создан Student: {0}'.format(self.name))

    def tell(self):
        SchoolMember.tell(self)
        print('Оценки {0:d}'.format(self.marks))


if __name__ == '__main__':

    t = Teacher('Teacher 1', 33, 80000)
    s = Student('Student 1', 22, 85)
    # Полиморфизм !
    members = [t, s]

    for member in members:
        '''
        ЗАМЕТЬТЕ что вызывается метод tell из ПОДКЛАССА, а не метод tell из класса SchoolMember. 
        Это можно понять следующим образом: Python всегда начинает поиск методов в самом классе, что он и делает в данном случае. 
        Если же он не находит метода, он начинает искать методы, принадлежащие базовым классам по очереди, в порядке, в котором они перечислены в кортеже при определении класса.
        '''
        member.tell()
