# coding=utf-8
'''
Простой способ сделать обертку над сокетами для получения ПРИМИТИВНОГО ПРОТОКОЛА УРОВНЯ ПАКЕТОВ и передавать таким образом большие файлы.
сокеты являются достаточно низкоуровневыми и не гарантируют доставку сообщения целиком. 
То есть, отправив большой объем данных, вы их получите, но, скорее всего, ПО ЧАСТЯМ. 
Фрагментация сообщений при передаче через сокеты приводит к тому, что НЕВОЗМОЖНО ЗАРАНЕЕ ЗНАТЬ РАЗМЕР ПОЛУЧАЕМОГО СООБЩЕНИЯ, 
а прием/передача с применением заведомо большего буфера также НЕ ГАРАНТИРУЕТ ПЕРЕДАЧУ ЗА ОДИН ВЫЗОВ socket.send.
Простейшим решением этой проблемы является добавление в начало посылки ее размера в байтах. 
Таким образом, первым вызовом recvall можно получать только размер (4 байта), который практически гарантированно будет передан в одном TCP пакете 
(фрагментация, как правило, возникает при передаче больше, чем 1 кБ), после чего считать из буфера оставшееся сообщение, длинна которого уже известна.

'''
import socket
import struct

__author__ = "vk.com/amsinitca"

class SuperSocket():
    def __init__(self, sock):
        self._sock = sock
    '''
    Для передачи большого сообщения (например, картинки) к нему, сформированным привычным образом (как для socket) 
    добавим в начало длину в байтах (в сетевом порядке следования байт) и отправим целиком через вызов socket.send.
    Реализуется это простой функцией:
    '''
    def send_msg(self, msg):
        # Каждое сообщение будет иметь префикс в 4 байта блинной(network byte order)
        msg = struct.pack('>I', len(msg)) + msg
        self._sock.send(msg)
    '''
		Получение пакета менее тривиально: первоначально напишем вспомогательную функцию для получения заданного числа байт:
		Так, пока не будет достигнут заданный размер, в byteArray добавляются принятые данные. 
		По достижению заданного размера возвращается весь принятый пакет.
	'''
    def recvall(self, n):
        # Функция для получения n байт или возврата None если получен EOF
        data = b''
        while len(data) < n:
            packet = self._sock.recv(n - len(data))
            if not packet:
                return None
            data += packet
        return data
    '''
    Метод для приема пакета целиком.
    
    Первоначально из сокета считывается размер сообщения (4 байта), распаковывается в целое число и, 
    узнав таким образом размер сообщения, получается остаток данных с помощью вспомогательной функции
    '''
    def recv_msg(self):
        # Получение длины сообщения и распаковка в integer
        raw_msglen = self.recvall(4)
        if not raw_msglen:
            return None
        msglen = struct.unpack('>I', raw_msglen)[0]
        # Получение данных
        return self.recvall(msglen)

s = SuperSocket()