''''''
'''
    Допустим, мы хотим быть уверены, что мы всегда создаём ИСКЛЮЧИТЕЛЬНО ЭКЗЕМПЛЯРЫ ПОДКЛАССОВ класса SchoolMember, 
    и не создаём экземпляры самого класса SchoolMember.
    Для достижения этой цели мы можем использовать концепцию под названием «абстрактные базовые классы». 
    Это означает, что такой класс абстрактен, т.е. является лишь некой КОНЦЕПЦИЕЙ,
    НЕ ПРЕДНАЗНАЧЕННОЙ ДЛЯ ИСПОЛЬЗОВАНИЯ В КАЧЕСТВЕ РЕАЛЬНОГО КЛАССА
    Мы можем объявить наш класс как абстрактный базовый класс при помощи встроенного метакласса по имени ABCMeta.
'''
from abc import *
'''
    Точно так же, как классы используются для создания объектов, можно использовать МЕТАКЛАССЫ для СОЗДАНИЯ КЛАССОВ. 
    Метаклассы существуют для ИЗМЕНЕНИЯ или добавления НОВОГО ПОВЕДЕНИЯ в классы.
    
    Мой комментарий: Я так думаю, что в данном контексте мы изменили базовый класс на абстрактный при помощи метакласслв
    об этом говорит использование metaclass = ABCMeta в скобках при наследовании ниже
'''
class SchoolMember(metaclass = ABCMeta): # указать именно таким образом metaclass = ABCMeta
    '''Базовый(суперкласс для классов Student и Teacher. Представляет любого человека в школе.'''
    '''    
    Можно создать для них независимые классы и работать с ними, но тогда добавление какой-либо новой общей характеристики 
    потребует добавления её к каждому из этих независимых классов в отдельности, что делает программу неповоротливой.
    студента наследовали этот класс, т.е. чтобы они стали подтипами этого типа (класса), после чего добавить любые
    специфические характеристики к этим подтипам.
    Заметьте также, что код родительского класса используется МНОГОКРАТНО,
    и НЕТ НЕОБХОДИМОСТИ КОПИРОВАТЬ ЕГО ВО ВСЕ КЛАССЫ, как пришлось бы в случае использования независимых классов.
    '''

    def __init__(self, name, age):
        self.name = name
        self.age = age
        print('(Создан SchoolMember: {0})'.format(self.name))
    '''
    Мы можем объявить метод tell класса SchoolMember абстрактным, и таким образом автоматически запретим создавать экземпляры класса SchoolMember. 
    Тем не менее, мы можем работать с экземплярами Teacher и Student так, как будто они экземпляры SchoolMember, поскольку они являются подклассами.
    
    '''
    @abstractmethod
    def tell(self):
        '''Вывести информацию.'''
        print('Имя:"{0}" Возраст:"{1}"'.format(self.name, self.age), end=" ")


"""
Чтобы воспользоваться наследованием, при определении класса мы указываем имена его базовых классов в виде кортежа, 
следующего за сразу за его именем.
"""

class Teacher(SchoolMember):
    '''Представляет подкласс преподователя'''

    '''
    Метод __init__ базового класса вызывается явно при помощи переменной self, 
    чтобы инициализировать ЧАСТЬ ОБЪЕКТА, относящуюся к базовому классу
    Это очень важно запомнить: Python НЕ ВЫЗЫВАЕТ конструктор базового класса АВТОМАТИЧЕСКИ 
    – его необходимо вызывать самостоятельно в явном виде.
    '''
    def __init__(self, name, age, salary):
        SchoolMember.__init__(self, name, age)
        self.salary = salary
        print('Создан Teacher: {0}'.format(self.name))

    def tell(self):
        '''
        Здесь же мы видим, как можно вызывать методы базового класса, предваряя запись имени метода именем класса,
        а затем передавая переменную self вместе с другими аргументами.
        '''
        SchoolMember.tell(self)
        print('Зарплата {0:d}'.format(self.salary))


class Student(SchoolMember):
    ''' Представляет студента '''

    def __init__(self, name, age, marks):
        SchoolMember.__init__(self, name, age)
        self.marks = marks
        print('Создан Student: {0}'.format(self.name))

    def tell(self):
        SchoolMember.tell(self)
        print('Оценки {0:d}'.format(self.marks))
########################################################################################################################
'''
Пример и информация из Прохоренок - "самое необходимое"
Абстрактные методы содержат только определение метода БЕЗ РЕАЛИЗАЦИИ. 
Предполагается, что класс-потомок ДОЛЖЕН ПЕРЕОПРЕДЕЛИТЬ метод и РЕАЛИЗОВАТЬ его ФУНКЦИОНАЛЬНОСТЬ. 

Чтобы такое предположение сделать более ОЧЕВИДНЫМ, часто внутри абстрактного метода ВОЗБУЖДАЮТ ИСКЛЮЧЕНИЕ (ЗАПОМНИТЬ ПРАКТИКУ!)
'''
class Abstract_Class1:

    def func(self, x): # Абстрактный метод
        # Возбуждаем исключение с помощью raise
        raise NotImplementedError("Heoбxoдимo переопределить метод")
########################################################################################################################

class Class2(Abstract_Class1):   # Наследуем абстрактный метод
    def func(self, x):          # Переопределяем метод (тоже название)
        print(x)
########################################################################################################################

class ClassЗ(Abstract_Class1):   # Класс не переопределяет метод
    pass                        # Класс НЕ ПЕРЕОПРЕДЕЛЯЕТ метод
########################################################################################################################

if __name__ == '__main__':
    '''
    Тем не менее, мы можем работать с экземплярами Teacher и Student так, как будто они экземпляры SchoolMember, поскольку они являются подклассами SchoolMember.
    '''
    t = Teacher('Teacher 1', 33, 80000)
    s = Student('Student 1', 22, 85)
    #m = SchoolMember('abc',25) # TypeError: Can't instantiate abstract class SchoolMember with abstract methods tell
    # Полиморфизм !
    members = [t, s]

    for member in members:
        '''
        ЗАМЕТЬТЕ что вызывается метод tell из ПОДКЛАССА, а не метод tell из класса SchoolMember. 
        Это можно понять следующим образом: Python всегда начинает поиск методов в самом классе, что он и делает в данном случае. 
        Если же он не находит метода, он начинает искать методы, принадлежащие базовым классам по очереди, в порядке, в котором они перечислены в кортеже при определении класса.
        '''
        member.tell()
########################################################################################################################

# Закомментировать реализацию примеров выше для пущей наглядности
    с2 = Class2 ()
    с2.func(50)
    с3 = ClassЗ ( )

    #с3.func(50)

    try: #(ЗАПОМНИТЬ ПРАКТИКУ:)
        с3.func(50)
    # ВЫведет: 50 # Перехватываем исключения #Ошибка. Метод func() не переопределен
    except NotImplementedError as rnsg:
        print (rnsg) # Выведет: Необходимо переопределить метод